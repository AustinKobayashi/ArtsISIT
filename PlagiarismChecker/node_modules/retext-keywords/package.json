{
  "_from": "retext-keywords",
  "_id": "retext-keywords@4.0.1",
  "_inBundle": false,
  "_integrity": "sha512-XRkgwo1ye7LQrczp2mraaNsLHPqxjzsPrksJqpYdUERtj5GSCJXpxSe75AU9YjEVTrMdVAnYyq5FiDLEdD1eYA==",
  "_location": "/retext-keywords",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "retext-keywords",
    "fetchSpec": "latest",
    "name": "retext-keywords",
    "raw": "retext-keywords",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/retext-keywords/-/retext-keywords-4.0.1.tgz",
  "_shasum": "bffb3c2c85cccfe9e50fab35a461bba887d3f928",
  "_shrinkwrap": null,
  "_spec": "retext-keywords",
  "_where": "C:\\Users\\akobs\\Desktop\\PlagiarismChecker",
  "author": {
    "email": "tituswormer@gmail.com",
    "name": "Titus Wormer",
    "url": "http://wooorm.com"
  },
  "bugs": {
    "url": "https://github.com/wooorm/retext-keywords/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Titus Wormer",
      "email": "tituswormer@gmail.com",
      "url": "http://wooorm.com"
    },
    {
      "name": "Vladimir Starkov",
      "email": "iamstarkov@gmail.com"
    }
  ],
  "dependencies": {
    "nlcst-to-string": "^2.0.0",
    "retext-pos": "^2.0.0",
    "stemmer": "^1.0.0",
    "unist-util-visit": "^1.0.0"
  },
  "deprecated": false,
  "description": "Keyword extraction with Retext",
  "devDependencies": {
    "browserify": "^14.1.0",
    "esmangle": "^1.0.0",
    "nyc": "^11.0.0",
    "remark-cli": "^4.0.0",
    "remark-preset-wooorm": "^3.0.0",
    "retext": "^5.0.0",
    "tape": "^4.0.0",
    "xo": "^0.18.0"
  },
  "files": [
    "index.js"
  ],
  "homepage": "https://github.com/wooorm/retext-keywords#readme",
  "keywords": [
    "extraction",
    "keyword",
    "phrase",
    "retext",
    "term",
    "terminology"
  ],
  "license": "MIT",
  "name": "retext-keywords",
  "nyc": {
    "branches": 100,
    "check-coverage": true,
    "functions": 100,
    "lines": 100
  },
  "optionalDependencies": {},
  "readme": "# retext-keywords [![Build Status][travis-badge]][travis] [![Coverage Status][codecov-badge]][codecov]\n\nKeyword extraction with [**retext**][retext].\n\n## Installation\n\n[npm][]:\n\n```bash\nnpm install retext-keywords\n```\n\n## Usage\n\nSay we have the following file, `example.txt`, with the first three paragraphs\non [Term Extraction][term-extraction] from Wikipedia:\n\n```text\nTerminology mining, term extraction, term recognition, or glossary extraction, is a subtask of information extraction. The goal of terminology extraction is to automatically extract relevant terms from a given corpus.\n\nIn the semantic web era, a growing number of communities and networked enterprises started to access and interoperate through the internet. Modeling these communities and their information needs is important for several web applications, like topic-driven web crawlers, web services, recommender systems, etc. The development of terminology extraction is essential to the language industry.\n\nOne of the first steps to model the knowledge domain of a virtual community is to collect a vocabulary of domain-relevant terms, constituting the linguistic surface manifestation of domain concepts. Several methods to automatically extract technical terms from domain-specific document warehouses have been described in the literature.\n\nTypically, approaches to automatic term extraction make use of linguistic processors (part of speech tagging, phrase chunking) to extract terminological candidates, i.e. syntactically plausible terminological noun phrases, NPs (e.g. compounds \"credit card\", adjective-NPs \"local tourist information office\", and prepositional-NPs \"board of directors\" - in English, the first two constructs are the most frequent). Terminological entries are then filtered from the candidate list using statistical and machine learning methods. Once filtered, because of their low ambiguity and high specificity, these terms are particularly useful for conceptualizing a knowledge domain or for supporting the creation of a domain ontology. Furthermore, terminology extraction is a very useful starting point for semantic similarity, knowledge management, human translation and machine translation, etc.\n```\n\nAnd our script, `example.js`, looks as follows:\n\n```javascript\nvar vfile = require('to-vfile');\nvar retext = require('retext');\nvar keywords = require('retext-keywords');\nvar nlcstToString = require('nlcst-to-string');\n\nretext()\n  .use(keywords)\n  .process(vfile.readSync('example.txt'), function (err, file) {\n    if (err) throw err;\n\n    console.log('Keywords:');\n    file.data.keywords.forEach(function (keyword) {\n      console.log(nlcstToString(keyword.matches[0].node));\n    });\n\n    console.log();\n    console.log('Key-phrases:');\n    file.data.keyphrases.forEach(function (phrase) {\n      console.log(phrase.matches[0].nodes.map(nlcstToString).join(''));\n    });\n  }\n);\n```\n\nNow, running `node example` yields:\n\n```text\nKeywords:\nterm\nextraction\nTerminology\nweb\ndomain\n\nKey-phrases:\nterminology extraction\nterms\nterm extraction\nknowledge domain\ncommunities\n```\n\n## API\n\n### `retext().use(keywords[, options])`\n\nExtract keywords and key-phrases from the document.\n\nThe results are stored on `file.data`: keywords at `file.data.keywords`\nand key-phrases at `file.data.keyphrases`.  Both are lists.\n\nA single keyword looks as follows:\n\n```js\n{\n  stem: 'term',\n  score: 1,\n  matches: [\n    {node: Node, index: 5, parent: Node},\n    // ...\n  ],\n  // ...\n}\n```\n\n...and a key-phrase:\n\n```js\n{\n  score: 1,\n  weight: 11,\n  stems: ['terminolog', 'extract'],\n  value: 'terminolog extract',\n  matches:  [\n    {nodes: [Node, Node, Node], parent: Node},\n    // ...\n  ]\n}\n```\n\n###### `options`\n\n*   `maximum` (default: `5`) — Try to detect `words` and `phrases`\n    words;\n\n    Note that actual counts may differ.  For example, when two words\n    have the same score, both will be returned.  Or when too few words\n    exist, less will be returned. the same goes for phrases.\n\n## License\n\n[MIT][license] © [Titus Wormer][author]\n\n<!-- Definitions -->\n\n[travis-badge]: https://img.shields.io/travis/wooorm/retext-keywords.svg\n\n[travis]: https://travis-ci.org/wooorm/retext-keywords\n\n[codecov-badge]: https://img.shields.io/codecov/c/github/wooorm/retext-keywords.svg\n\n[codecov]: https://codecov.io/github/wooorm/retext-keywords\n\n[npm]: https://docs.npmjs.com/cli/install\n\n[license]: LICENSE\n\n[author]: http://wooorm.com\n\n[retext]: https://github.com/wooorm/retext\n\n[term-extraction]: http://en.wikipedia.org/wiki/Terminology_extraction\n",
  "readmeFilename": "readme.md",
  "remarkConfig": {
    "plugins": [
      "preset-wooorm"
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wooorm/retext-keywords.git"
  },
  "scripts": {
    "build": "npm run build-md && npm run build-bundle && npm run build-mangle",
    "build-bundle": "browserify index.js --ignore-missing --bare -s retextKeywords > retext-keywords.js",
    "build-mangle": "esmangle retext-keywords.js > retext-keywords.min.js",
    "build-md": "remark . -qfo",
    "lint": "xo",
    "test": "npm run build && npm run lint && npm run test-coverage",
    "test-api": "node test",
    "test-coverage": "nyc --reporter lcov tape test.js"
  },
  "version": "4.0.1",
  "xo": {
    "esnext": false,
    "ignores": [
      "retext-keywords.js"
    ],
    "rules": {
      "guard-for-in": "off",
      "max-lines": "off",
      "max-nested-callbacks": "off",
      "no-negated-condition": "off"
    },
    "space": true
  }
}
